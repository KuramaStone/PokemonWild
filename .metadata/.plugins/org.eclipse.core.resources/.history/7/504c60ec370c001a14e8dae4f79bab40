package me.brook.PokemonCreator.world.tile;

import java.awt.Point;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;

import javax.imageio.ImageIO;

import me.brook.PokemonCreator.world.yaml.Configuration;

public enum TileType {

	ERROR, GRASS, TALL_GRASS, RED_FLOWER, ORANGE_FLOWER, BLUE_FLOWER, YELLOW_FLOWER, SMALL_BUSH, LONG_BUSH, GRASS_PATH, SHORT_TREE;

	private static int idCount = 0;

	private int id;
	private BufferedImage[] images;
	private int animationCycle; // The number of ticks until it shall go to the next animation frame.

	private boolean isCollidable, isAnimated;

	public static void loadTileData() throws IOException {
		Configuration config = new Configuration(
				new File("C:\\Users\\Stone\\PokemonWild\\Pokemon Wild\\res\\tiles\\yml\\basic.yml"));

		// Load 1x1
		BufferedImage sheet = ImageIO.read(new File(
				"C:\\Users\\Stone\\PokemonWild\\Pokemon Wild\\res\\tiles\\" + config.get("textures.1x1.info.file")));

		for(Object obj : config.getKeys("textures.1x1")) {
			String str = obj.toString();

			if(!str.equals("info")) {
				TileType.valueOf(str.toUpperCase()).loadBasicTile(config, sheet);
			}
		}

		for(Object obj : config.getKeys("textures.varied")) {
			String str = obj.toString();

			if(!str.equals("info")) {
				TileType.valueOf(str.toUpperCase()).loadTallTile(config, sheet);
			}
		}

	}

	private void loadTallTile(Configuration config, BufferedImage sheet) {
		String name = this.toString().toLowerCase();
		config.setSection("textures.varied" + name);

		isCollidable = config.getBoolean("collidable");
		isAnimated = config.getBoolean("animated");

		id = idCount++;
		int variants = config.getInt("variants");
		images = new BufferedImage[variants];
		animationCycle = config.getInt("cycle");
		
		// Load the variants using these coordinates
		Point start = config.getPoint("location.start");
		Point end = config.getPoint("location.end");
		
	}

	private void loadBasicTile(Configuration config, BufferedImage sheet) {
		// We load the tile data now from the basic.yml
		String name = this.toString().toLowerCase();
		int size = 16;
		config.setSection("textures.1x1." + name);

		isCollidable = config.getBoolean("collidable");
		isAnimated = config.getBoolean("animated");

		id = idCount++;
		int variants = config.getInt("variants");
		images = new BufferedImage[variants];
		animationCycle = config.getInt("cycle");
		
		// Load the variants using these coordinates
		Point start = config.getPoint("location.start");
		Point end = config.getPoint("location.end");

		if(end == null) {
			for(int i = 0; i < variants; i++) { // Additional pieces are in the x-axis
				int tx = (i + start.x) * size;
				int ty = (start.y) * size;

				try {
					images[i] = sheet.getSubimage(tx, ty, size, size);
				}
				catch(Exception e) {
					e.printStackTrace();
				}
			}
		}
		else {
			variants = (end.x - start.x + 1) * (end.y - start.y + 1);
			images = new BufferedImage[variants];
			int i = 0;
			for(int x = start.x; x <= end.x; x++) {
				for(int y = start.y; y <= end.y; y++) {
					int tx = x * size;
					int ty = y * size;

					try {
						BufferedImage image = sheet.getSubimage(tx, ty, size, size);

						if(isEmpty(image)) { // If tile is empty, then don't load it
							BufferedImage[] dest = new BufferedImage[images.length - 1];
							for(int j = 0; j < dest.length; j++) {
								dest[j] = images[j];
							}
							images = dest;
						}
						else {
							images[i++] = image;
						}

					}
					catch(Exception e) {
						e.printStackTrace();
					}
				}
			}
		}
		config.setSection("");
	}

	private static boolean isEmpty(BufferedImage image) {
		for(int x = 0; x < image.getWidth(); x++) {
			for(int y = 0; y < image.getHeight(); y++) {
				if(image.getRGB(x, y) != 0) { // -16777216 is the rgb value if the pixel is transparent
					return false;
				}
			}
		}
		return true;
	}

	public int getID() {
		return id;
	}

	public boolean isCollidable() {
		return isCollidable;
	}

	public boolean isAnimated() {
		return isAnimated;
	}

	public BufferedImage[] getImages() {
		return images;
	}

	public BufferedImage getCurrentImage() {
		return images[currentFrame];
	}
	
	private int currentFrame = 0;
	private int ticks = 0;

	public void tickAnimation() {
		if(!isAnimated) {
			currentFrame = 0;
			return;
		}
		
		int currentTransition = ticks / animationCycle;
		currentFrame = currentTransition;
		
		ticks++;
		ticks %= (animationCycle * images.length); // This is the total number of ticks it takes the animation to restart
	}

}
